<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Astronave con SLAM</title>
  
  <!-- A-Frame for rendering the scene -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  
  <!-- OpenCV.js library -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" onerror="onOpenCvError()"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }
    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      overflow: hidden;
    }
  </style>
</head>
<body style="margin: 0; overflow: hidden;">

<!-- A-Frame Scene -->
<a-scene embedded 
         renderer="colorManagement: true, physicallyCorrectLights" 
         vr-mode-ui="enabled: false" 
         device-orientation-permission-ui="enabled: false">
    
  <a-assets>
      <a-asset-item id="astro" src="ASTRONAVE.glb"></a-asset-item>
  </a-assets>

  <!-- Astronave Model at fixed position -->
  <a-entity id="astronave" position="0 0 -10" gltf-model="#astro" scale="1 1 1"></a-entity>

  <!-- Camera for AR scene -->
  <a-camera id="ar-camera" position="0 0 0" look-controls="enabled: false" class="clickable"></a-camera>

  <!-- Visualizzazione del piano 3D -->
  <a-plane id="plane" position="0 0 0" rotation="-90 0 0" width="10" height="10" color="#CCC" opacity="0.5"></a-plane>
  
</a-scene>

<!-- Video Feed from Camera -->
<video id="video" autoplay></video>
<canvas id="canvas"></canvas>

<script type="text/javascript">
  let cvLoaded = false;
  let isPlaneAnchored = false; // Variabile per verificare se il piano è ancorato

  function onOpenCvReady() {
    cvLoaded = true;
    console.log('OpenCV.js is ready.');
    initializeApp();
  }

  function onOpenCvError() {
    console.error('OpenCV.js failed to load.');
  }

  function initializeApp() {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const debugCanvas = document.createElement('canvas'); // Canvas per il debug
    const debugCtx = debugCanvas.getContext('2d');
    const ctx = canvas.getContext('2d');
    const camera = document.getElementById('ar-camera');
    const astronave = document.getElementById('astronave');
    const plane = document.querySelector('#plane'); // Usa querySelector per garantire che venga trovato l'elemento

    debugCanvas.style.position = 'absolute';
    debugCanvas.style.top = '0';
    debugCanvas.style.left = '0';
    debugCanvas.style.width = '100vw'; // A tutto schermo
    debugCanvas.style.height = '100vh'; // A tutto schermo
    debugCanvas.style.pointerEvents = 'none'; // Assicura che il canvas di debug non interferisca con gli altri eventi
    document.body.appendChild(debugCanvas);

    let lastX = 0, lastY = 0, lastZ = 0;
    const smoothingFactor = 0.1;
    const depthScale = 1;
    let planeAnchor = { x: 0, y: 0, z: 0 };

    navigator.mediaDevices.getUserMedia({ 
      video: { facingMode: true }
    })
    .then((stream) => {
      video.srcObject = stream;
      video.addEventListener('loadedmetadata', () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        debugCanvas.width = canvas.width;
        debugCanvas.height = canvas.height;
        video.play();
      });
      video.addEventListener('play', () => {
        processVideo();
      });
    })
    .catch((error) => {
      console.error('Errore nell\'accesso alla fotocamera: ', error);
    });

    function detectFeatures() {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      const src = cv.matFromImageData(imageData);
      const gray = new cv.Mat();
      const corners = new cv.Mat();

      // Converti l'immagine in scala di grigi
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

      if (gray.empty()) {
        console.error('L\'immagine in scala di grigi è vuota!');
        src.delete();
        gray.delete();
        corners.delete();
        return [];
      }

      // Usa goodFeaturesToTrack per rilevare i punti
      // Modifica i parametri per rendere il numero di punti più fitto
      const maxCorners = 10000;  // Aumenta il numero massimo di punti
      const qualityLevel = 0.001; // Mantieni la qualità bassa per rilevare più punti
      const minDistance = 5;    // Riduci la distanza minima tra i punti

      cv.goodFeaturesToTrack(gray, corners, maxCorners, qualityLevel, minDistance);
      console.log(`Numero di punti rilevati: ${corners.rows}`);

      const points = [];
      for (let i = 0; i < corners.rows; i++) {
        const pt = corners.row(i).data32F;
        points.push({ x: pt[0], y: pt[1] });
      }

      src.delete(); gray.delete(); corners.delete();
      return points;
    }

    function estimate3DPlane(points2D) {
      // Assicurati di avere abbastanza punti
      if (points2D.length < 3) {
        console.error('Non ci sono abbastanza punti per stimare un piano 3D.');
        return null;
      }

      // Converti i punti 2D in punti 3D
      const points3D = points2D.map(p => ({
        x: (p.x / canvas.width) * 10 - 5,
        y: Math.max((p.y / canvas.height) * 10 - 5, 0),
        z: depthScale
      }));

      // Costruisci la matrice di design A e il vettore b per il sistema lineare Ax = b
      let A = [];
      let b = [];

      points3D.forEach(p => {
        A.push([p.x, p.y, 1]);
        b.push(-p.z);
      });

      // Converti in matrici OpenCV
      let matA = cv.matFromArray(A.length, A[0].length, cv.CV_32F, A.flat());
      let matB = cv.matFromArray(b.length, 1, cv.CV_32F, b);

      // Calcola il piano usando il metodo dei minimi quadrati
      let matX = new cv.Mat();
      try {
        cv.solve(matA, matB, matX, cv.DECOMP_SVD);
      } catch (error) {
        console.error('Errore nel calcolo dei coefficienti del piano:', error);
        matA.delete();
        matB.delete();
        matX.delete();
        return null;
      }

      // I coefficienti del piano
      let planeCoefficients = matX.data32F;

      if (planeCoefficients.length < 4) {
        console.error('Errore nel calcolo dei coefficienti del piano. Assicurati di avere abbastanza punti.');
        matA.delete();
        matB.delete();
        matX.delete();
        return null;
      }

      matA.delete();
      matB.delete();
      matX.delete();

      // Restituisci i coefficienti del piano
      return {
        A: planeCoefficients[0],
        B: planeCoefficients[1],
        C: planeCoefficients[2],
        D: planeCoefficients[3]
      };
    }

    function drawDebug(points, plane) {
      debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
      debugCtx.strokeStyle = 'red';
      debugCtx.fillStyle = 'red';
      debugCtx.lineWidth = 2;

      // Disegna i punti
      points.forEach(p => {
        debugCtx.beginPath();
        debugCtx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
        debugCtx.fill();
      });

      // Disegna il piano stimato, se esiste
      if (plane) {
        debugCtx.strokeStyle = 'blue';
        debugCtx.beginPath();
        debugCtx.moveTo(0, (-plane.D - plane.A * 0) / plane.B);
        debugCtx.lineTo(canvas.width, (-plane.D - plane.A * canvas.width) / plane.B);
        debugCtx.stroke();
      }
    }

    function estimateCameraPose(points) {
      if (points.length > 0) {
        const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

        const x3D = (avgX / canvas.width) * 10 - 5;
        const y3D = Math.max((avgY / canvas.height) * 10 - 5, 0);
        const zEstimate = depthScale;

        const smoothedX = lastX * (1 - smoothingFactor) + x3D * smoothingFactor;
        const smoothedY = lastY * (1 - smoothingFactor) + y3D * smoothingFactor;
        const smoothedZ = lastZ * (1 - smoothingFactor) + zEstimate * smoothingFactor;

        camera.setAttribute('position', `${smoothedX * 10} ${Math.max(smoothedY * 10, 0)} ${smoothedZ}`);
        console.log(`Posizione della camera aggiornata: X=${smoothedX * 10}, Y=${Math.max(smoothedY * 10, 0)}, Z=${smoothedZ}`);

        lastX = smoothedX;
        lastY = smoothedY;
        lastZ = smoothedZ;
      } else {
        console.log("Nessun punto rilevato.");
      }
    }

    function anchorPlane(points) {
      if (points.length > 500) {
        // Calcola il piano 3D usando i punti
        const planeCoefficients = estimate3DPlane(points);

        if (planeCoefficients) {
          // Anchora il piano nella scena
          if (!isPlaneAnchored) {
            const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

            const newX = (avgX / canvas.width) * 10 - 5;
            const newY = Math.max((avgY / canvas.height) * 10 - 5, 0);
            const newZ = 0;  // Imposta Z come fisso

            // Imposta la posizione e la rotazione del piano in A-Frame
            plane.setAttribute('position', `${newX} ${newY} ${newZ}`);
            plane.setAttribute('rotation', '-90 0 0');  // Ruota il piano per essere orizzontale

            console.log(`Piano ancorato a: X=${newX}, Y=${newY}, Z=${newZ}`);

            isPlaneAnchored = true;  // Assicurati che il piano sia ancorato solo una volta
          }
        }
      }
    }

    function processVideo() {
      const points = detectFeatures();
      anchorPlane(points);  // L'ancoraggio avviene solo quando viene rilevato un piano
      estimateCameraPose(points); // Aggiorniamo la posizione della camera
      drawDebug(points, estimate3DPlane(points)); // Disegna punti e piano sul canvas di debug
      requestAnimationFrame(processVideo);
    }
  }
</script>

</body>
</html>
