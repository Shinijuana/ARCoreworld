<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Astronave con SLAM</title>
  
  <!-- A-Frame per rendering -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  
  <!-- OpenCV.js library -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" onerror="onOpenCvError()"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }
    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      overflow: hidden;
    }
    #debugCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
      pointer-events: none;
    }
  </style>
</head>
<body>

<!-- A-Frame Scene -->
<a-scene embedded 
         renderer="colorManagement: true, physicallyCorrectLights" 
         vr-mode-ui="enabled: false" 
         device-orientation-permission-ui="enabled: false">
    
  <a-assets>
      <a-asset-item id="astro" src="ASTRONAVE.glb"></a-asset-item>
  </a-assets>

  <!-- Modello Astronave -->
  <a-entity id="astronave" position="0 0 -10" gltf-model="#astro" scale="1 1 1"></a-entity>

  <!-- Camera -->
  <a-camera id="ar-camera" position="0 0 0" look-controls="enabled: false" class="clickable"></a-camera>
  
  <!-- Piano per riferimento -->
  <a-plane id="plane" position="0 0 0" rotation="-90 0 0" width="10" height="10" color="#CCC" opacity="0.5"></a-plane>
  
</a-scene>

<!-- Video Camera Feed -->
<video id="video" autoplay></video>
<canvas id="canvas"></canvas>
<canvas id="debugCanvas"></canvas>

<script type="text/javascript">
let cvLoaded = false;
let isPlaneAnchored = false;

// Coordinate fisse astronave
let anchorX = 0, anchorY = 0, anchorZ = -10;

function onOpenCvReady() {
  cvLoaded = true;
  console.log('OpenCV.js is ready.');
  initializeApp();
}

function onOpenCvError() {
  console.error('OpenCV.js failed to load.');
}

function initializeApp() {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const debugCanvas = document.getElementById('debugCanvas');
  const debugCtx = debugCanvas.getContext('2d');
  const ctx = canvas.getContext('2d');
  const camera = document.getElementById('ar-camera');
  const astronave = document.getElementById('astronave');

  let lastX = 0, lastY = 0, lastZ = 0;
  const smoothingFactor = 0.1;
  const depthScale = 1;
  
  let accumulatedPlanes = []; // Per mediare i risultati
  const numFramesToAverage = 5;

  navigator.mediaDevices.getUserMedia({ 
    video: { facingMode: true }
  })
  .then((stream) => {
    video.srcObject = stream;
    video.addEventListener('loadedmetadata', () => {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      debugCanvas.width = canvas.width;
      debugCanvas.height = canvas.height;
      video.play();
    });
    video.addEventListener('play', () => {
      processVideo();
    });
  })
  .catch((error) => {
    console.error('Errore nell\'accesso alla fotocamera: ', error);
  });

  function detectFeatures() {
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    const src = cv.matFromImageData(imageData);
    const gray = new cv.Mat();
    const corners = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    if (gray.empty()) {
      console.error('L\'immagine in scala di grigi Ã¨ vuota!');
      src.delete();
      gray.delete();
      corners.delete();
      return [];
    }

    const maxCorners = 1000;
    const qualityLevel = 0.01;
    const minDistance = 5;

    cv.goodFeaturesToTrack(gray, corners, maxCorners, qualityLevel, minDistance);
    console.log(`Numero di punti rilevati: ${corners.rows}`);

    const points = [];
    for (let i = 0; i < corners.rows; i++) {
      const pt = corners.row(i).data32F;
      points.push({ x: pt[0], y: pt[1] });
    }

    // Disegno punti su debugCanvas
    debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
    debugCtx.strokeStyle = 'red';
    points.forEach(p => {
      debugCtx.beginPath();
      debugCtx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
      debugCtx.stroke();
    });

    src.delete(); gray.delete(); corners.delete();
    return points;
  }

  function filterPoints(points) {
    return points.filter(p => p.x >= 0 && p.y >= 0 && p.x < canvas.width && p.y < canvas.height);
  }

  function estimate3DPlaneRANSAC(points2D) {
    const filteredPoints = filterPoints(points2D);
    if (filteredPoints.length < 3) {
      console.error('Non ci sono abbastanza punti validi per stimare un piano 3D.');
      return null;
    }

    let bestPlane = null;
    let bestInliersCount = 0;
    const iterations = 100;
    const threshold = 0.01;

    for (let i = 0; i < iterations; i++) {
      const randomIndices = [];
      while (randomIndices.length < 3) {
        const rand = Math.floor(Math.random() * filteredPoints.length);
        if (!randomIndices.includes(rand)) {
          randomIndices.push(rand);
        }
      }

      const sample = randomIndices.map(idx => filteredPoints[idx]);
      const plane = estimate3DPlane(sample);

      let inliersCount = 0;
      filteredPoints.forEach(p => {
        const distance = Math.abs(plane.A * p.x + plane.B * p.y + plane.C * p.z + plane.D);
        if (distance < threshold) {
          inliersCount++;
        }
      });

      if (inliersCount > bestInliersCount) {
        bestInliersCount = inliersCount;
        bestPlane = plane;
      }
    }

    console.log(`Miglior piano trovato con ${bestInliersCount} inliers.`);
    return bestPlane;
  }

  function estimate3DPlane(points3D) {
    if (points3D.length < 3) {
      return null;
    }

    let A = [];
    let b = [];

    points3D.forEach(p => {
      A.push([p.x, p.y, 1]);
      b.push(-p.z);
    });

    let matA = cv.matFromArray(A.length, A[0].length, cv.CV_32F, A.flat());
    let matB = cv.matFromArray(b.length, 1, cv.CV_32F, b);

    let matX = new cv.Mat();
    cv.solve(matA, matB, matX, cv.DECOMP_SVD);

    let planeCoefficients = matX.data32F;

    matA.delete();
    matB.delete();
    matX.delete();

    return {
      A: planeCoefficients[0],
      B: planeCoefficients[1],
      C: planeCoefficients[2],
      D: planeCoefficients[3]
    };
  }

  function estimateCameraPose(points) {
    if (points.length > 1000) {
      const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
      const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

      const x3D = (avgX / canvas.width) * 10 - 5;
      const y3D = Math.max((avgY / canvas.height) * 10 - 5, 0);

      // Posizione con smoothing
      const smoothedX = lastX + (x3D - lastX) * smoothingFactor;
      const smoothedY = lastY + (y3D - lastY) * smoothingFactor;
      const smoothedZ = lastZ + (depthScale - lastZ) * smoothingFactor;

      // Aggiorna la posizione dell'astronave
      astronave.setAttribute('position', `${smoothedX * 0.5} ${smoothedY * 0.5} ${smoothedZ}`);

      lastX = smoothedX;
      lastY = smoothedY;
      lastZ = smoothedZ;
    }
  }

  function processVideo() {
    const points = detectFeatures();
    const plane = estimate3DPlaneRANSAC(points);
    estimateCameraPose(points);

    if (!isPlaneAnchored && plane) {
      isPlaneAnchored = true;
      const avgPlane = accumulateAndAveragePlanes(plane);
      // Applica la media al piano (logica aggiuntiva da implementare qui)
    }

    requestAnimationFrame(processVideo);
  }

  function accumulateAndAveragePlanes(newPlane) {
    if (accumulatedPlanes.length >= numFramesToAverage) {
      accumulatedPlanes.shift();
    }
    accumulatedPlanes.push(newPlane);

    const avgPlane = accumulatedPlanes.reduce((acc, plane) => {
      acc.A += plane.A;
      acc.B += plane.B;
      acc.C += plane.C;
      acc.D += plane.D;
      return acc;
    }, { A: 0, B: 0, C: 0, D: 0 });

    return {
      A: avgPlane.A / accumulatedPlanes.length,
      B: avgPlane.B / accumulatedPlanes.length,
      C: avgPlane.C / accumulatedPlanes.length,
      D: avgPlane.D / accumulatedPlanes.length
    };
  }
}

</script>
</body>
</html>
