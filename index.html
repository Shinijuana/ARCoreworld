<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Astronave con SLAM</title>
  
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" onerror="onOpenCvError()"></script>

  <style>
    body { margin: 0; overflow: hidden; }
    #video, #canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; }
    a-scene { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; overflow: hidden; }
    #debugCanvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; pointer-events: none; }
  </style>
</head>
<body>

<a-scene embedded renderer="colorManagement: true, physicallyCorrectLights" vr-mode-ui="enabled: false" device-orientation-permission-ui="enabled: false">
  <a-assets><a-asset-item id="astro" src="ASTRONAVE.glb"></a-asset-item></a-assets>
  <a-entity id="astronave" position="0 0 -2" gltf-model="#astro" scale="1 1 1"></a-entity>
  <a-camera id="ar-camera" position="0 0 0" look-controls="enabled: false" class="clickable"></a-camera>
  <a-plane id="plane" position="0 0 0" rotation="-90 0 0" width="10" height="10" color="#CCC" opacity="0.5"></a-plane>
</a-scene>

<video id="video" autoplay></video>
<canvas id="canvas"></canvas>
<canvas id="debugCanvas"></canvas>

<script type="text/javascript">
let cvLoaded = false;
let isPlaneAnchored = false;
let detectedPlane = null; // To store the detected stable plane
const anchorX = 0, anchorY = 0, anchorZ = -2;

class KalmanFilter {
  constructor(processNoise, measurementNoise, estimatedError) {
    this.processNoise = processNoise;
    this.measurementNoise = measurementNoise;
    this.estimatedError = estimatedError;
    this.posteriEstimate = 0;
    this.posteriError = 1;
  }

  update(measurement) {
    const prioriEstimate = this.posteriEstimate;
    const prioriError = this.posteriError + this.processNoise;
    const blendingFactor = prioriError / (prioriError + this.measurementNoise);
    this.posteriEstimate = prioriEstimate + blendingFactor * (measurement - prioriEstimate);
    this.posteriError = (1 - blendingFactor) * prioriError;
    return this.posteriEstimate;
  }
}

const kalmanX = new KalmanFilter(0.1, 1, 1);
const kalmanY = new KalmanFilter(0.1, 1, 1);
const kalmanZ = new KalmanFilter(0.1, 1, 1);

function onOpenCvReady() {
  cvLoaded = true;
  console.log('OpenCV.js is ready.');
  initializeApp();
}

function onOpenCvError() {
  console.error('OpenCV.js failed to load.');
}

function initializeApp() {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const debugCanvas = document.getElementById('debugCanvas');
  const debugCtx = debugCanvas.getContext('2d');
  const ctx = canvas.getContext('2d');
  const camera = document.getElementById('ar-camera');

  const depthScale = 1;<script type="text/javascript">
let cvLoaded = false;
let isPlaneAnchored = false;
let detectedPlane = null; // To store the detected stable plane
const anchorX = 0, anchorY = 0, anchorZ = -2;

class KalmanFilter {
  constructor(processNoise, measurementNoise, estimatedError) {
    this.processNoise = processNoise;
    this.measurementNoise = measurementNoise;
    this.estimatedError = estimatedError;
    this.posteriEstimate = 0;
    this.posteriError = 1;
  }

  update(measurement) {
    const prioriEstimate = this.posteriEstimate;
    const prioriError = this.posteriError + this.processNoise;
    const blendingFactor = prioriError / (prioriError + this.measurementNoise);
    this.posteriEstimate = prioriEstimate + blendingFactor * (measurement - prioriEstimate);
    this.posteriError = (1 - blendingFactor) * prioriError;
    return this.posteriEstimate;
  }
}

const kalmanX = new KalmanFilter(0.1, 1, 1);
const kalmanY = new KalmanFilter(0.1, 1, 1);
const kalmanZ = new KalmanFilter(0.1, 1, 1);

let allPlanes = []; // To store all detected planes

function onOpenCvReady() {
  cvLoaded = true;
  console.log('OpenCV.js is ready.');
  initializeApp();
}

function onOpenCvError() {
  console.error('OpenCV.js failed to load.');
}

function initializeApp() {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const debugCanvas = document.getElementById('debugCanvas');
  const debugCtx = debugCanvas.getContext('2d');
  const ctx = canvas.getContext('2d');
  const camera = document.getElementById('ar-camera');

  const depthScale = 1;

  navigator.mediaDevices.getUserMedia({ 
    video: { facingMode: "environment" }
  })
  .then((stream) => {
    video.srcObject = stream;
    video.addEventListener('loadedmetadata', () => {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      debugCanvas.width = canvas.width;
      debugCanvas.height = canvas.height;
      video.play();
    });
    video.addEventListener('play', () => {
      processVideo();
    });
  })
  .catch((error) => {
    console.error('Errore nell\'accesso alla fotocamera: ', error);
  });

  function detectFeatures() {
    const orb = new cv.ORB();
    const keypoints = new cv.KeyPointVector();
    const descriptors = new cv.Mat();

    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const src = cv.matFromImageData(ctx.getImageData(0, 0, canvas.width, canvas.height));
    const gray = new cv.Mat();
    const blurred = new cv.Mat();
    
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);

    orb.detect(blurred, keypoints);
    
    const points = [];
    for (let i = 0; i < keypoints.size(); i++) {
      const keypoint = keypoints.get(i);
      points.push({ x: keypoint.pt.x, y: keypoint.pt.y });
    }

    src.delete();
    gray.delete();
    blurred.delete();
    keypoints.delete();
    descriptors.delete();
    
    return points;
  }

  function filterPoints(points) {
    const meanX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
    const meanY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

    const threshold = 50;
    return points.filter(p => {
      const distance = Math.sqrt(Math.pow(p.x - meanX, 2) + Math.pow(p.y - meanY, 2));
      return distance < threshold;
    });
  }

  function estimate3DPlane(points2D) {
    if (points2D.length < 4) {
      console.error('Non ci sono abbastanza punti per stimare un piano.');
      return null;
    }

    const points3D = points2D.map(p => {
      const depth = 1 + (p.y / canvas.height); // Stima della profondità
      return {
        x: (p.x / canvas.width) * 10 - 5, // Scala per avere coordinate 3D
        y: Math.max((p.y / canvas.height) * 10 - 5, 0), // Evitare valori negativi per Y
        z: depth * depthScale
      };
    });

    const centroid = points3D.reduce((sum, p) => ({
      x: sum.x + p.x / points3D.length,
      y: sum.y + p.y / points3D.length,
      z: sum.z + p.z / points3D.length
    }), { x: 0, y: 0, z: 0 });

    let sumNormalX = 0, sumNormalY = 0, sumNormalZ = 0;
    for (let i = 0; i < points3D.length - 1; i++) {
      const p1 = points3D[i];
      const p2 = points3D[i + 1];

      const normalX = (p1.y - centroid.y) * (p2.z - centroid.z) - (p1.z - centroid.z) * (p2.y - centroid.y);
      const normalY = (p1.z - centroid.z) * (p2.x - centroid.x) - (p1.x - centroid.x) * (p2.z - centroid.z);
      const normalZ = (p1.x - centroid.x) * (p2.y - centroid.y) - (p1.y - centroid.y) * (p2.x - centroid.x);

      sumNormalX += normalX;
      sumNormalY += normalY;
      sumNormalZ += normalZ;
    }

    const avgNormalX = sumNormalX / points3D.length;
    const avgNormalY = sumNormalY / points3D.length;
    const avgNormalZ = sumNormalZ / points3D.length;

    const normalMagnitude = Math.sqrt(avgNormalX * avgNormalX + avgNormalY * avgNormalY + avgNormalZ * avgNormalZ);
    const normalizedNormal = {
      x: avgNormalX / normalMagnitude,
      y: avgNormalY / normalMagnitude,
      z: avgNormalZ / normalMagnitude
    };

    const tolerance = 0.2;
    const isParallelToFloor = Math.abs(normalizedNormal.y) > (1 - tolerance);

    const planeExtent = Math.abs(points3D[0].x - points3D[1].x) > 2 && Math.abs(points3D[0].y - points3D[2].y) > 2;

    if (isParallelToFloor && planeExtent) {
      return points3D;
    } else {
      console.log('Superficie scartata: non è parallela al pavimento o troppo piccola.');
      return null;
    }
  }

  function combinePlanes(newPlane) {
    allPlanes.push(...newPlane);

    const totalPoints = allPlanes.length;
    const centroid = allPlanes.reduce((sum, p) => ({
      x: sum.x + p.x / totalPoints,
      y: sum.y + p.y / totalPoints,
      z: sum.z / totalPoints
    }), { x: 0, y: 0, z: 0 });

    let sumNormalX = 0, sumNormalY = 0, sumNormalZ = 0;
    for (let i = 0; i < allPlanes.length - 1; i++) {
      const p1 = allPlanes[i];
      const p2 = allPlanes[i + 1];

      const normalX = (p1.y - centroid.y) * (p2.z - centroid.z) - (p1.z - centroid.z) * (p2.y - centroid.y);
      const normalY = (p1.z - centroid.z) * (p2.x - centroid.x) - (p1.x - centroid.x) * (p2.z - centroid.z);
      const normalZ = (p1.x - centroid.x) * (p2.y - centroid.y) - (p1.y - centroid.y) * (p2.x - centroid.x);

      sumNormalX += normalX;
      sumNormalY += normalY;
      sumNormalZ += normalZ;
    }

    const avgNormalX = sumNormalX / allPlanes.length;
    const avgNormalY = sumNormalY / allPlanes.length;
    const avgNormalZ = sumNormalZ / allPlanes.length;

    const normalMagnitude = Math.sqrt(avgNormalX * avgNormalX + avgNormalY * avgNormalY + avgNormalZ * avgNormalZ);
    const normalizedNormal = {
      x: avgNormalX / normalMagnitude,
      y: avgNormalY / normalMagnitude,
      z: avgNormalZ / normalMagnitude
    };

    const tolerance = 0.2;
    if (Math.abs(normalizedNormal.y) > (1 - tolerance)) {
      console.log('Piano combinato con successo');
      return allPlanes;
    } else {
      console.log('Piano scartato: normale non allineata con Y.');
      return null;
    }
  }

  function processVideo() {
    if (!cvLoaded) {
      requestAnimationFrame(processVideo);
      return;
    }

    const points = detectFeatures();
    const filteredPoints = filterPoints(points);
    const plane = estimate3DPlane(filteredPoints);
    
    if (plane) {
      const combinedPlane = combinePlanes(plane);
      if (combinedPlane) {
        const meanZ = combinedPlane.reduce((sum, p) => sum + p.z, 0) / combinedPlane.length;
        const smoothedX = kalmanX.update(combinedPlane[0].x);
        const smoothedY = kalmanY.update(combinedPlane[0].y);
        const smoothedZ = kalmanZ.update(meanZ);
        camera.object3D.position.set(smoothedX, smoothedY, smoothedZ);
      }
    }

    requestAnimationFrame(processVideo);
  }
}
</script>

</body>
</html>
