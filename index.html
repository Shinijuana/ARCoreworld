<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Astronave con SLAM</title>
  
  <!-- A-Frame for rendering the scene -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  
  <!-- OpenCV.js library -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" onerror="onOpenCvError()"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }
    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      overflow: hidden;
    }
    #debugCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 2;
      pointer-events: none;
    }
  </style>
</head>
<body style="margin: 0; overflow: hidden;">

<!-- A-Frame Scene -->
<a-scene embedded 
         renderer="colorManagement: true, physicallyCorrectLights" 
         vr-mode-ui="enabled: false" 
         device-orientation-permission-ui="enabled: false">
    
  <a-assets>
      <a-asset-item id="astro" src="ASTRONAVE.glb"></a-asset-item>
  </a-assets>

  <!-- Astronave Model at fixed position -->
  <a-entity id="astronave" position="0 0 -2" gltf-model="#astro" scale="1 1 1"></a-entity>

  <!-- Camera for AR scene -->
  <a-camera id="ar-camera" position="0 0 0" look-controls="enabled: false" class="clickable"></a-camera>

  <!-- Visualizzazione del piano 3D -->
  <a-plane id="plane" position="0 0 0" rotation="-90 0 0" width="10" height="10" color="#CCC" opacity="0.5"></a-plane>
  
</a-scene>

<!-- Video Feed from Camera -->
<video id="video" autoplay></video>
<canvas id="canvas"></canvas>
<canvas id="debugCanvas"></canvas>

<script type="text/javascript">
let cvLoaded = false;
let isPlaneAnchored = false; // Variabile per verificare se il piano Ã¨ ancorato

// Coordinate fisse dell'astronave nel mondo 3D
const anchorX = 0, anchorY = 0, anchorZ = -2;

// Esempio base di filtro di Kalman
class KalmanFilter {
  constructor(processNoise, measurementNoise, estimatedError) {
    this.processNoise = processNoise;
    this.measurementNoise = measurementNoise;
    this.estimatedError = estimatedError;
    this.posteriEstimate = 0;
    this.posteriError = 1;
  }

  update(measurement) {
    const prioriEstimate = this.posteriEstimate;
    const prioriError = this.posteriError + this.processNoise;
    const blendingFactor = prioriError / (prioriError + this.measurementNoise);
    this.posteriEstimate = prioriEstimate + blendingFactor * (measurement - prioriEstimate);
    this.posteriError = (1 - blendingFactor) * prioriError;
    return this.posteriEstimate;
  }
}

const kalmanX = new KalmanFilter(0.1, 1, 1);
const kalmanY = new KalmanFilter(0.1, 1, 1);

function onOpenCvReady() {
  cvLoaded = true;
  console.log('OpenCV.js is ready.');
  initializeApp();
}

function onOpenCvError() {
  console.error('OpenCV.js failed to load.');
}

function initializeApp() {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const debugCanvas = document.getElementById('debugCanvas');
  const debugCtx = debugCanvas.getContext('2d');
  const ctx = canvas.getContext('2d');
  const camera = document.getElementById('ar-camera');

  let lastX = 0, lastY = 0, lastZ = 0;
  const depthScale = 1;

  const positionHistory = [];
  const maxHistoryLength = 5;

  navigator.mediaDevices.getUserMedia({ 
    video: { facingMode: "environment" }
  })
  .then((stream) => {
    video.srcObject = stream;
    video.addEventListener('loadedmetadata', () => {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      debugCanvas.width = canvas.width;
      debugCanvas.height = canvas.height;
      video.play();
    });
    video.addEventListener('play', () => {
      processVideo();
    });
  })
  .catch((error) => {
    console.error('Errore nell\'accesso alla fotocamera: ', error);
  });

  // Funzione per il rilevamento delle caratteristiche usando ORB
  function detectFeatures() {
  const orb = new cv.ORB();
  const keypoints = new cv.KeyPointVector(); // Crea un oggetto KeyPointVector
  const descriptors = new cv.Mat();

  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const src = cv.matFromImageData(ctx.getImageData(0, 0, canvas.width, canvas.height));
  const gray = new cv.Mat();
  const blurred = new cv.Mat();
  
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);  // Riduzione del rumore

  orb.detect(blurred, keypoints); // Passa il KeyPointVector
  
  const points = [];
  for (let i = 0; i < keypoints.size(); i++) { // Usa keypoints.size() per iterare
    const keypoint = keypoints.get(i); // Ottieni il singolo KeyPoint
    points.push({ x: keypoint.pt.x, y: keypoint.pt.y }); // Accedi alle coordinate del punto
  }

  src.delete();
  gray.delete();
  blurred.delete();
  keypoints.delete(); // Libera memoria di KeyPointVector
  descriptors.delete();
  
  return points;
}


  function filterPoints(points) {
    return points.filter(p => p.x >= 0 && p.y >= 0 && p.x < canvas.width && p.y < canvas.height);
  }

  // Funzione per stimare il piano usando RANSAC
  function estimate3DPlaneRANSAC(points2D) {
    const points3D = points2D.map(p => ({
      x: (p.x / canvas.width) * 10 - 5,
      y: Math.max((p.y / canvas.height) * 10 - 5, 0),
      z: depthScale
    }));

    if (points3D.length < 4) {
      console.error('Non ci sono abbastanza punti per stimare un piano.');
      return null;
    }

    const maxIterations = 1000;
    const threshold = 0.01;
    let bestPlane = null;
    let bestInliers = 0;

    for (let i = 0; i < maxIterations; i++) {
      const samplePoints = [];
      while (samplePoints.length < 3) {
        const index = Math.floor(Math.random() * points3D.length);
        if (!samplePoints.includes(points3D[index])) {
          samplePoints.push(points3D[index]);
        }
      }

      const plane = computePlaneFromPoints(samplePoints);

      let inliersCount = 0;
      points3D.forEach(p => {
        const distance = Math.abs(plane.A * p.x + plane.B * p.y + plane.C * p.z + plane.D);
        if (distance < threshold) {
          inliersCount++;
        }
      });

      if (inliersCount > bestInliers) {
        bestInliers = inliersCount;
        bestPlane = plane;
      }
    }

    return bestPlane;
  }

  function computePlaneFromPoints(points) {
    const p1 = points[0], p2 = points[1], p3 = points[2];
    const v1 = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };
    const v2 = { x: p3.x - p1.x, y: p3.y - p1.y, z: p3.z - p1.z };

    const A = v1.y * v2.z - v1.z * v2.y;
    const B = v1.z * v2.x - v1.x * v2.z;
    const C = v1.x * v2.y - v1.y * v2.x;
    const D = -(A * p1.x + B * p1.y + C * p1.z);

    return { A, B, C, D };
  }

  function smoothPosition(x, y, z) {
    if (positionHistory.length >= maxHistoryLength) {
      positionHistory.shift();
    }
    positionHistory.push({ x, y, z });

    const avgX = positionHistory.reduce((sum, p) => sum + p.x, 0) / positionHistory.length;
    const avgY = positionHistory.reduce((sum, p) => sum + p.y, 0) / positionHistory.length;
    const avgZ = positionHistory.reduce((sum, p) => sum + p.z, 0) / positionHistory.length;

    return { x: avgX, y: avgY, z: avgZ };
  }

  // Funzione per stimare la posizione della camera
  function estimateCameraPose(points) {
    if (points.length > 100) {
      const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
      const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

      const x3D = (avgX / canvas.width) * 10 - 5;
      const y3D = Math.max((avgY / canvas.height) * 10 - 5, 0);

      const smoothedX = kalmanX.update(x3D);
      const smoothedY = kalmanY.update(y3D);
      const smoothedZ = 0;

      const smoothPos = smoothPosition(smoothedX, smoothedY, smoothedZ);

      camera.setAttribute('position', `${smoothPos.x} ${Math.max(smoothPos.y, 0)} ${smoothPos.z}`);
      console.log(`Posizione della camera aggiornata: X=${smoothPos.x}, Y=${Math.max(smoothPos.y, 0)}, Z=${smoothPos.z}`);

      lastX = smoothPos.x;
      lastY = smoothPos.y;
      lastZ = smoothPos.z;
    } else {
      console.log("Nessun punto rilevato.");
    }
  }

  function anchorPlane(points, plane) {
    if (plane && !isPlaneAnchored) {
      const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
      const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

      const newX = (avgX / canvas.width) * 10 - 5;
      const newY = Math.max((avgY / canvas.height) * 10 - 5, 0);
      const newZ = 9;

      const smoothedX = kalmanX.update(newX);
      const smoothedY = kalmanY.update(newY);

      const smoothPos = smoothPosition(smoothedX, smoothedY, newZ);

      camera.setAttribute('position', `${smoothPos.x} ${Math.max(smoothPos.y, 0)} ${smoothPos.z}`);
      console.log(`Piano ancorato: X=${smoothPos.x}, Y=${Math.max(smoothPos.y, 0)}, Z=${smoothPos.z}`);
      
      isPlaneAnchored = true;
    }
  }

  // Funzione principale per elaborare il video frame per frame
  function processVideo() {
    if (!cvLoaded) {
      return;
    }

    const points = detectFeatures();
    const filteredPoints = filterPoints(points);
    
    const plane = estimate3DPlaneRANSAC(filteredPoints);
    
    if (!isPlaneAnchored) {
      anchorPlane(filteredPoints, plane);
    }

    estimateCameraPose(filteredPoints);

    requestAnimationFrame(processVideo);
  }
}

document.addEventListener('DOMContentLoaded', initializeApp);
</script>

</body>
</html>
