<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR SLAM Basic</title>
  
  <!-- A-Frame for rendering the scene -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  
  <!-- OpenCV.js library -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" onerror="onOpenCvError()"></script>
   <script src="https://cdn.jsdelivr.net/npm/kalmanjs/kalman.min.js"></script>


  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }
    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 2; /* Ensure it's above the debug canvas */
      overflow: hidden;
    }
    #debugCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1; /* Between video and A-Frame scene */
      pointer-events: none;
    }
  </style>
</head>
<body>

<a-scene embedded 
         renderer="colorManagement: true, physicallyCorrectLights" 
         vr-mode-ui="enabled: false" 
         device-orientation-permission-ui="enabled: false">
    
  <a-assets>
      <a-asset-item id="astro" src="ASTRONAVE.glb"></a-asset-item>
  </a-assets>

  <a-entity id="astronave" position="0 0 -2" gltf-model="#astro" scale="1 1 1"></a-entity>
  <a-camera id="ar-camera" position="0 0 0" look-controls="enabled: false" class="clickable"></a-camera>
  <a-plane id="plane" position="0 0 0" rotation="-90 0 0" width="10" height="10" color="#CCC" opacity="0.5"></a-plane>
  
</a-scene>

<video id="video" autoplay></video>
<canvas id="canvas"></canvas>
<canvas id="debugCanvas"></canvas>

<script type="text/javascript">
let cvLoaded = false;
let isPlaneAnchored = false;

const anchorX = 0, anchorY = 0, anchorZ = -2;

class KalmanFilter {
  constructor(processNoise, measurementNoise, estimatedError) {
    this.processNoise = processNoise;
    this.measurementNoise = measurementNoise;
    this.estimatedError = estimatedError;
    this.posteriEstimate = 0;
    this.posteriError = 1;
  }

  update(measurement) {
    const prioriEstimate = this.posteriEstimate;
    const prioriError = this.posteriError + this.processNoise;
    const blendingFactor = prioriError / (prioriError + this.measurementNoise);
    this.posteriEstimate = prioriEstimate + blendingFactor * (measurement - prioriEstimate);
    this.posteriError = (1 - blendingFactor) * prioriError;
    return this.posteriEstimate;
  }
}

const kalmanX = new KalmanFilter(0.1, 1, 1);
const kalmanY = new KalmanFilter(0.1, 1, 1);
const kalmanZ = new KalmanFilter(0.1, 1, 1); // Add Kalman filter for Z

function onOpenCvReady() {
  cvLoaded = true;
  console.log('OpenCV.js is ready.');
  initializeApp();
}

function onOpenCvError() {
  console.error('OpenCV.js failed to load.');
}

function initializeApp() {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const debugCanvas = document.getElementById('debugCanvas');
  const debugCtx = debugCanvas.getContext('2d');
  const ctx = canvas.getContext('2d');
  const camera = document.getElementById('ar-camera');

  let lastX = 0, lastY = 0, lastZ = 0;
  const depthScale = 1;
  const positionHistory = [];
  const maxHistoryLength = 5;

  navigator.mediaDevices.getUserMedia({ 
    video: { facingMode: "environment" }
  })
  .then((stream) => {
    video.srcObject = stream;
    video.addEventListener('loadedmetadata', () => {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      debugCanvas.width = canvas.width;
      debugCanvas.height = canvas.height;
      video.play();
    });
    video.addEventListener('play', () => {
      processVideo();
    });
  })
  .catch((error) => {
    console.error('Errore nell\'accesso alla fotocamera: ', error);
  });

  // Funzione di rilevamento caratteristiche ORB
  function detectFeatures() {
    const orb = new cv.ORB();
    const keypoints = new cv.KeyPointVector();
    const descriptors = new cv.Mat();

    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const src = cv.matFromImageData(ctx.getImageData(0, 0, canvas.width, canvas.height));
    const gray = new cv.Mat();
    const blurred = new cv.Mat();
    
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);

    orb.detect(blurred, keypoints);
    
    const points = [];
    for (let i = 0; i < keypoints.size(); i++) {
      const keypoint = keypoints.get(i);
      points.push({ x: keypoint.pt.x, y: keypoint.pt.y });
    }

    src.delete();
    gray.delete();
    blurred.delete();
    keypoints.delete();
    descriptors.delete();
    
    return points;
  }

  // Filtro per rimuovere outliers
  function filterPoints(points) {
    const meanX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
    const meanY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

    const threshold = 50; // Threshold for outlier removal
    return points.filter(p => {
      const distance = Math.sqrt(Math.pow(p.x - meanX, 2) + Math.pow(p.y - meanY, 2));
      return distance < threshold;
    });
  }

  // Funzione per stimare il piano 3D
function estimate3DPlane(points2D) {
  // Continua solo se ci sono abbastanza punti
  if (points2D.length < 4) return null;

  const points3D = points2D.map(p => {
    const depth = 1 + (p.y / canvas.height);  // Stima la profondità
    return {
      x: (p.x / canvas.width) * 10 - 5,
      y: Math.max((p.y / canvas.height) * 10 - 5, 0),
      z: depth * depthScale
    };
  });

  // Calcola un punto medio per ancorare l'astronave
  const avgX = points3D.reduce((sum, p) => sum + p.x, 0) / points3D.length;
  const avgY = points3D.reduce((sum, p) => sum + p.y, 0) / points3D.length;
  const avgZ = points3D.reduce((sum, p) => sum + p.z, 0) / points3D.length;

  return { x: avgX, y: avgY, z: avgZ };
}

function isStable(planePoint) {
  // Implementa una logica per vedere se il punto è stabile, per ora mettiamo una tolleranza fissa
  return Math.abs(planePoint.x) < 5 && Math.abs(planePoint.y) < 5 && Math.abs(planePoint.z) < 5;
}



  // Processamento video in tempo reale
 function processVideo() {
    const features = detectFeatures();
    const filteredFeatures = filterPoints(features);
    
    if (filteredFeatures.length > 0) {
        const planeNormal = estimate3DPlane(filteredFeatures);

        if (planeNormal) {
            // Simula l'aggiornamento della fotocamera nel mondo 3D
            const smoothX = kalmanX.update(planeNormal.x);
            const smoothY = kalmanY.update(planeNormal.y);
            const smoothZ = kalmanZ.update(planeNormal.z);

            camera.setAttribute('position', `${smoothX} ${smoothY} ${smoothZ}`);
        }

        // Aggiungi il codice qui per gestire l'astronave
        const planePoint = estimate3DPlane(filteredFeatures);
        if (planePoint && isStable(planePoint)) {
            document.getElementById('astronave').setAttribute('position', `${planePoint.x} ${planePoint.y} ${planePoint.z}`);
        }
    }

    // Disegna i punti rilevati nel canvas di debug
    debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
    filteredFeatures.forEach(p => {
        debugCtx.beginPath();
        debugCtx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
        debugCtx.fillStyle = "red";
        debugCtx.fill();
        debugCtx.stroke();
    });

    requestAnimationFrame(processVideo);
}


window.addEventListener('devicemotion', (event) => {
  const acceleration = event.accelerationIncludingGravity;
  const rotationRate = event.rotationRate;

  // Se vuoi usare solo l'accelerazione senza gravità
  const accelWithoutGravity = event.acceleration;

  // Usa i dati di accelerazione
  let accelX = acceleration.x;  // Acceleration along X-axis
  let accelY = acceleration.y;  // Acceleration along Y-axis
  let accelZ = acceleration.z;  // Acceleration along Z-axis
  
  // Usa i dati di rotazione
  let rotX = rotationRate.alpha; // Rotazione attorno all'asse Z (gradi al secondo)
  let rotY = rotationRate.beta;  // Rotazione attorno all'asse X (gradi al secondo)
  let rotZ = rotationRate.gamma; // Rotazione attorno all'asse Y (gradi al secondo)

  // Normalizza i dati e applica un filtro per ridurre il rumore
  accelX = kalmanX.update(accelX);
  accelY = kalmanY.update(accelY);
  accelZ = kalmanZ.update(accelZ);

  // Aggiorna la posizione della telecamera in base ai dati di accelerazione
  // Il valore 0.01 serve a scalare il movimento per renderlo più fluido e meno drastico
  const newPosX = camera.getAttribute('position').x + accelX * 0.01;
  const newPosY = camera.getAttribute('position').y + accelY * 0.01;
  const newPosZ = camera.getAttribute('position').z + accelZ * 0.01;

  camera.setAttribute('position', `${newPosX} ${newPosY} ${newPosZ}`);

  // Se vuoi aggiornare anche la rotazione della telecamera:
  const currentRotation = camera.getAttribute('rotation');
  const newRotX = currentRotation.x + rotX * 0.1; // Scaling for smoother rotation
  const newRotY = currentRotation.y + rotY * 0.1;
  const newRotZ = currentRotation.z + rotZ * 0.1;

  camera.setAttribute('rotation', `${newRotX} ${newRotY} ${newRotZ}`);
});

}
</script>
</body>
</html>
