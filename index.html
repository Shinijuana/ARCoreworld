<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR Astronave con SLAM</title>
  
  <!-- A-Frame for rendering the scene -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  
  <!-- OpenCV.js library -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" onerror="onOpenCvError()"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }
    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      overflow: hidden;
    }
  </style>
</head>
<body style="margin: 0; overflow: hidden;">

<!-- A-Frame Scene -->
<a-scene embedded 
         renderer="colorManagement: true, physicallyCorrectLights" 
         vr-mode-ui="enabled: false" 
         device-orientation-permission-ui="enabled: false">
    
  <a-assets>
      <a-asset-item id="astro" src="ASTRONAVE.glb"></a-asset-item>
  </a-assets>

  <!-- Astronave Model at fixed position -->
  <a-entity id="astronave" position="0 0 -10" gltf-model="#astro" scale="1 1 1"></a-entity>

  <!-- Camera for AR scene -->
  <a-camera id="ar-camera" position="0 0 0" look-controls="enabled: false" class="clickable"></a-camera>
  
</a-scene>

<!-- Video Feed from Camera -->
<video id="video" autoplay></video>
<canvas id="canvas"></canvas>

<script type="text/javascript">
 let cvLoaded = false;
let isPlaneAnchored = false; // Variabile per verificare se il piano è ancorato

// Coordinate fisse dell'astronave nel mondo 3D
let anchorX = 0, anchorY = 0, anchorZ = -10;

function onOpenCvReady() {
  cvLoaded = true;
  console.log('OpenCV.js is ready.');
  initializeApp();
}

function onOpenCvError() {
  console.error('OpenCV.js failed to load.');
}

function initializeApp() {
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const camera = document.getElementById('ar-camera');
  const astronave = document.getElementById('astronave');

  let lastX = 0, lastY = 0, lastZ = 0;
  const smoothingFactor = 0.1;
  const depthScale = 1;

  navigator.mediaDevices.getUserMedia({ 
    video: { facingMode: true }
  })
  .then((stream) => {
    video.srcObject = stream;
    video.addEventListener('loadedmetadata', () => {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      video.play();
    });
    video.addEventListener('play', () => {
      processVideo();
    });
  })
  .catch((error) => {
    console.error('Errore nell\'accesso alla fotocamera: ', error);
  });

  function detectFeatures() {
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    const src = cv.matFromImageData(imageData);
    const gray = new cv.Mat();
    const corners = new cv.Mat();

    // Converti l'immagine in scala di grigi
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    if (gray.empty()) {
      console.error('L\'immagine in scala di grigi è vuota!');
      src.delete();
      gray.delete();
      corners.delete();
      return [];
    }

    // Usa goodFeaturesToTrack per rilevare i punti
    cv.goodFeaturesToTrack(gray, corners, 500, 0.01, 10);
    console.log(`Numero di punti rilevati: ${corners.rows}`);

    if (corners.rows > 0) {
      const points = [];
      for (let i = 0; i < corners.rows; i++) {
        const pt = corners.row(i).data32F;
        points.push({ x: pt[0], y: pt[1] });
      }
      src.delete(); gray.delete(); corners.delete();
      return points;
    } else {
      src.delete(); gray.delete(); corners.delete();
      return [];
    }
  }

  function estimateCameraPose(points) {
    if (points.length > 0) {
      const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
      const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

      // Calcolo della posizione 3D stimata basata sui punti rilevati
      const x3D = (avgX / canvas.width) * 10 - 5;
      const y3D = Math.max((avgY / canvas.height) * 10 - 5, 0);  // Y non può scendere sotto 0
      const zEstimate = (avgX / canvas.width) * 10 - 5;

      // Smussamento per evitare salti bruschi
      const smoothedX = lastX * (1 - smoothingFactor) + x3D * smoothingFactor;
      const smoothedY = lastY * (1 - smoothingFactor) + y3D * smoothingFactor;
      const smoothedZ = lastZ * (1 - smoothingFactor) + zEstimate * smoothingFactor;

      // Moltiplica i valori per un fattore di 10
      const amplifiedX = smoothedX * 10;
      const amplifiedY = smoothedY * 10;
      const amplifiedZ = smoothedZ * 10;

      // Aggiornamento della posizione della camera
      camera.setAttribute('position', `${amplifiedX} ${amplifiedY} ${amplifiedZ}`);
      console.log(`Posizione della camera aggiornata: X=${amplifiedX}, Y=${amplifiedY}, Z=${amplifiedZ}`);

      lastX = smoothedX;
      lastY = smoothedY;
      lastZ = smoothedZ;
    } else {
      console.log("Nessun punto rilevato.");
    }
  }

  // La funzione per ancorare l'astronave sarà eseguita solo quando viene rilevato un piano
  function anchorAstronave(points) {
    if (points.length > 1000) { // Ad esempio, richiedi almeno 20 punti per il piano
      // Cambia l'ancoraggio dell'astronave al tocco
      document.addEventListener('click', function () {
        const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
        const avgZ = points.reduce((sum, p) => sum + p.x, 0) / points.length;

        const newX = (avgX / canvas.width) * 10 - 5;
        const newY = Math.max((avgY / canvas.height) * 10 - 5, 0);  // Y non può scendere sotto 0
        const newZ = (avgZ / canvas.width) * 10 - 5;

        astronave.setAttribute('position', `${newX * 10} ${newY * 10} ${newZ * 10}`);
        console.log(`Astronave spostata a: X=${newX * 10}, Y=${newY * 10}, Z=${newZ * 10}`);
      });
    }
  }

  function processVideo() {
    const points = detectFeatures();
    if (!isPlaneAnchored) {
      anchorAstronave(points);  // L'ancoraggio avviene solo quando viene rilevato un piano
    }
    estimateCameraPose(points); // Aggiorniamo la posizione della camera
    requestAnimationFrame(processVideo);
  }
}

</script>

</body>
</html>
